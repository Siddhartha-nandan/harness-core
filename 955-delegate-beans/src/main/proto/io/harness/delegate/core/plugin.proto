// Copyright 2022 Harness Inc. All rights reserved.
// Use of this source code is governed by the PolyForm Free Trial 1.0.0 license
// that can be found in the licenses directory at the root of this repository, also available at
// https://polyformproject.org/wp-content/uploads/2020/05/PolyForm-Free-Trial-1.0.0.txt.

syntax = "proto3";

package io.harness.delegate.core;

option java_multiple_files = true;

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";

/*
 All data that is needed to execute the job
 */
message PluginDescriptor {
  string id = 1;
  ExecutionMode mode = 2;
  ExecutionPriority priority = 3;
  ExecutionEnvironment runtime = 4;
  PluginInput input = 5;
  repeated PluginSecret input_secrets = 6;
  repeated Resource resources = 7;
  string logging_token = 8;
  string callback_token = 9;
}

/*
 Specifies the execution mode of the Job. Delegate doesn't really care about sync/async (everything is async), but cares
 about how many times the job runs and at which priority. UNKNOWN mode should not be used
 */
enum ExecutionMode {
  MODE_UNKNOWN = 0;
  MODE_ONCE = 1;
  MODE_PERPETUAL = 2;
}

/*
  Most of the jobs should be DEFAULT priority. For anything that is related to rendering UI we can use HIGH. UNKNOWN
  priority should not be used
 */
enum ExecutionPriority {
  PRIORITY_UNKNOWN = 0;
  PRIORITY_DEFAULT = 1;
  PRIORITY_HIGH = 2;
}

/*
  All the data needed to decrypt one or many secrets from specific secret manager using certain runtime environment
 */
message PluginSecret {
  PluginInput secrets = 1;           // PluginInput may contain any number of secrets, not necessarily just one
  ExecutionEnvironment runtime = 2;  // Environment where the decryption should take place
  SecretConfig config = 3;           // Config that can be used to deserialize all secrets from input
}

/*
  Defines the environment under which the job needs to be executed.
 */
message ExecutionEnvironment {
  PluginType type = 1;
  PluginSource source = 2;
  string using = 3;
  ExecutionInfrastructure infra = 4;
  ResourceRequirements resource = 5;
  PluginInit init = 6;
  ExecutionSchedule schedule = 7;
}

/*
  Defines the secret manager configuration needed to access the secrets.
 */
message SecretConfig {
  oneof data {
    google.protobuf.Any proto_data = 1;  // for executions with proto spec.
    bytes binary_data = 2;               // for executions with any unstructured data formats including legacy kryo
  }
}

/*
  How to get runnable binary of the plugin e.g. docker image, git repo, binary to execute etc... UNKNOWN source should
  not be used
 */
enum PluginSource {
  SOURCE_UNKNOWN = 0;
  SOURCE_IMAGE = 1;
  SOURCE_GIT = 2;
}

/*
  Defines where will the job be executed by delegate. By default delegate will run it inside the same infra where it's
  running
 */
message ExecutionInfrastructure {
  // TODO: apart from basic infra details we need some sort of credentials or connector information here
  // e.g. imagePullSecret for pulling private images (not sure connector is useful for that since it's not delegate that
  // pull image, it provides them for K8S) or GH credentials to do git clone etc...
}

/*
  Any data about resource requirements (e.g. for container)
 */
message ResourceRequirements {
  string memory = 1;
  string cpu = 2;
  int32 replicas = 3;
  google.protobuf.Duration timeout = 4;
}

/*
  Anything needed to init the plugin (e.g. init script)
 */
message PluginInit {
  // TODO: This can be some sort of init script we run
}

/*
 Schedule is for perpetual execution support. No reason perpetual jobs should have a separate definition. They are same
 as standard jobs, just run on a schedule.
 */
message ExecutionSchedule {
  google.protobuf.Duration interval = 1;  // Interval between successive iterations
  google.protobuf.Duration timeout = 2;   // Timeout for one iteration of the job
}

/*
 Any parameters describing the job. data needs to be in byte format as delegate might be just passing it through without
 deserialization. Other fields can be interpreted by delegate.
 */
message PluginInput {
  // We could use only bytes, but Any gives us additional benefit of knowing the runtime data type for a negligible
  // additional size in bytes. There might also be a minimal performance penalty. There is nothing preventing users
  // using plain proto objects as bytes bypassing Any
  oneof data {
    google.protobuf.Any proto_data = 1;  // for executions with proto spec.
    bytes binary_data = 2;               // for executions with any unstructured data formats including legacy kryo
  }
}

/*
 Type of the plugin, can be anything from enum TaskType or any additional 3rd party plugins
 */
message PluginType {
  string type = 1;
}

/*
  Intended for defining any additional resources the plugin should use, e.g. additional volume
 */
message Resource {
  string path = 1;
  ResourceType type = 2;
}

/*
  Supported resource types. UNKNOWN resource type should not be used
 */
enum ResourceType {
  RES_UNKNOWN = 0;
  RES_VOLUME = 1;
}