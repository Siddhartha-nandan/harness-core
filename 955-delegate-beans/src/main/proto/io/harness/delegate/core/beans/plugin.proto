// Copyright 2022 Harness Inc. All rights reserved.
// Use of this source code is governed by the PolyForm Free Trial 1.0.0 license
// that can be found in the licenses directory at the root of this repository, also available at
// https://polyformproject.org/wp-content/uploads/2020/05/PolyForm-Free-Trial-1.0.0.txt.

syntax = "proto3";

package io.harness.delegate.core.beans;

option java_multiple_files = true;

import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";

/*
 All data that is needed to execute the job
 */
message TaskDescriptor {
  string id = 1;  // Id for the task
  ExecutionMode mode = 2;
  ExecutionPriority priority = 3;
  ExecutionType execution_type = 4;
  ExecutionEnvironment runtime = 5;       // Environment in which the task should run
  TaskInput input = 6;                    // Task inputs
  repeated TaskSecret input_secrets = 7;  // Task secrets. One instance can contain multiple secrets from same provider
  //  repeated Resource resources = 8;        // Any additional resources the task might need (e.g. shared locations)
  string logging_token = 9;    // Token for sending logs to logging service
  string callback_token = 10;  // Token for sending notify event to the service that initiated a task
}

/*
 Specifies the execution mode of the Job. Delegate doesn't really care about sync/async (everything is async), but cares
 about how many times the job runs and at which priority. UNKNOWN mode should not be used
 */
enum ExecutionMode {
  MODE_UNKNOWN = 0;
  MODE_ONCE = 1;
  MODE_SCHEDULE = 2;
}

/*
  Most of the jobs should be DEFAULT priority. For anything that is related to rendering UI we can use HIGH. UNKNOWN
  priority should not be used
 */
enum ExecutionPriority {
  PRIORITY_UNKNOWN = 0;
  PRIORITY_DEFAULT = 1;
  PRIORITY_HIGH = 2;
}

enum ExecutionType {
  TYPE_UNKNOWN = 0;
  TYPE_PLUGIN = 1;
  TYPE_BACKGROUND = 2;
}
/*
  All the data needed to decrypt one or many secrets from specific secret manager using certain runtime environment
 */
// TODO: Revisit this message depending how secrets will work. - also used as infra secret which doesn't have runtime
message TaskSecret {
  TaskInput secrets = 1;             // TaskInput may contain any number of secrets, not necessarily just one
  ExecutionEnvironment runtime = 2;  // Environment where the decryption should take place
  SecretConfig config = 3;           // Config that can be used to deserialize all secrets from input
}

/*
  Defines the environment under which the job needs to be executed.
 */
// FixMe: Figure out what goes into infra and what stays here and if we need both
message ExecutionEnvironment {
  string type = 1;  // Type of the plugin, can be anything from enum TaskType or any additional 3rd party plugins. It
                    // can be left out if plugin can execute a single type of task
  PluginSource source = 2;
  string uses = 3;  // source dependant location of the plugin (e.g. docker image tag, git repo etc...)
  ResourceRequirements resource = 6;  // Resource requirements for infra types that need it (e.g. K8S CPU/Mem)
  PluginInit init = 7;                // Any kind of init that needs to happen for the plugin (e.g. init script)
  map<string, string> env = 8;
  repeated string command = 9;
  repeated string arg = 10;
  SecurityContext security_context = 11;  // Startup user id for the execution infra
  string working_dir = 12;                // Working dir that all tasks have read/write access to
  ExecutionSchedule schedule = 14;        // Schedule on which the plugin runs, applies only for MODE_PERPETUAL
}

/*
  Defines the secret manager configuration needed to access the secrets.
 */
message SecretConfig {
  oneof data {
    google.protobuf.Any proto_data = 1;  // for executions with proto spec.
    bytes binary_data = 2;               // for executions with any unstructured data formats including legacy kryo
  }
}

/*
  How to get runnable binary of the plugin e.g. docker image, git repo, binary to execute etc... UNKNOWN source should
  not be used
 */
enum PluginSource {
  SOURCE_UNKNOWN = 0;
  SOURCE_IMAGE = 1;
  SOURCE_GIT = 2;
}

/*
  Any data about resource requirements (e.g. for container)
 */
message ResourceRequirements {
  string memory = 1;
  string cpu = 2;
  int32 replicas = 3;
  google.protobuf.Duration timeout = 4;
}

/*
  Anything needed to init the plugin (e.g. init script)
 */
message PluginInit {
  // TODO: This can be some sort of init script we run
}
/*
  Defines security context for running a task. Note these values would always be there (unless entire context is
  omitted) with their defaults. E.g.
    privileged = false; runAsUser = 0 (root); runAsNonRoot = false; allowPrivilegeEscalation = false;

 */
message SecurityContext {
  bool allowPrivilegeEscalation = 1;
  bool privileged = 2;
  string procMount = 3;
  bool readOnlyRootFilesystem = 4;
  bool runAsNonRoot = 5;
  int64 runAsGroup = 6;
  int64 runAsUser = 7;
  repeated string add_capability = 8;
  repeated string drop_capability = 9;
}

/*
 Schedule is for perpetual execution support. No reason perpetual jobs should have a separate definition. They are same
 as standard jobs, just run on a schedule.
 */
message ExecutionSchedule {
  google.protobuf.Duration interval = 1;  // Interval between successive iterations
  google.protobuf.Duration timeout = 2;   // Timeout for one iteration of the job
}

/*
 Any parameters describing the job. data needs to be in byte format as delegate might be just passing it through without
 deserialization. Other fields can be interpreted by delegate.
 */
message TaskInput {
  // We could use only bytes, but Any gives us additional benefit of knowing the runtime data type for a negligible
  // additional size in bytes. There might also be a minimal performance penalty. There is nothing preventing users
  // using plain proto objects as bytes bypassing Any
  oneof data {
    google.protobuf.Any proto_data = 1;  // for executions with proto spec.
    bytes binary_data = 2;               // for executions with any unstructured data formats including legacy kryo
  }
}